//==================================Базовая конфигурация===============================================
const regex = /регулярно выражаюсь/; // Обязательно заключать в слеши (литералы регулярного выражения)
console.log(regex); // Результат: /регулярно выражаюсь/

//==================================Поисковая система===============================================
const userList = "Маша, Петя, Катя, Лёша, Лера, Иннокентий, Влад";
const innokentiy = /Иннокентий/g;
userList.match(innokentiy); // [ "Иннокентий" ]

//==================================Какой-то текст написанный рандомно===============================================
const comments = [
  "Я пользуюсь iPhone 6s — всё летает.",
  "У меня последний самсунг, всё хорошо.",
  "Зачем платить больше, если есть Xiaomi?",
  "Лучший телефон - Nokia 3310. У меня до сих пор работает.",
  "Только последний iPhone — там улучшили водонепроницаемость.",
];

const $_regex = /iPhone/;
const iPhoneComments = comments.filter((item) => $_regex.test(item));

/* метод test проверяет, есть ли искомая строка
в тексте и возвращает true или false.
Позже разберём этот метод подробно. */

console.log(iPhoneComments);

/* [
  "Я пользуюсь iPhone 6s — всё летает.",
  "Только последний iPhone — там улучшили водонепроницаемость."
] */

/*
На поиск влияют три сущности:
Спецсимволы — содержатся в самóм регулярном выражении и позволяют тоньше задать поиск. Например, искать в тексте сразу «Яндекс» и «Yandex».
Методы — определяют, что нужно делать, когда строка найдена: заменить её или сообщить, где произошло совпадение.
Флаги — кастомизируют работу метода, то есть увеличивают возможности. Например, выставив флаг, можно найти все совпадения с регуляркой или только одно.
Если кратко: спецсимволы определяют, что искать, методы — что делать, а флаги — как делать.
*/

//1.Методы строк:
const regex = /л/;
const word = "солнце";

word.match(regex); // [ "л" ] — метод нашёл символ в строке

/* match — строковый метод. Поэтому мы вызываем его
как метод строки, а регулярное выражение передаём как аргумент. */

//2.Методы регулярных выражений
const regex = /т/;
const word = "лестница";

regex.test(word); // true — метод подтвердил, что в строке есть совпадение

/* test — метод объекта RegExp. Поэтому мы вызываем его
как метод переменной regExp и передаём строку как аргумент. */

//==================================Флаги===============================================
/*
Флаг — символ, который стоит в регулярном выражении в самом конце (после слеша) и задаёт настройки поиска. 
Всего их шесть: g, i, m, u, y, s. В регулярном выражении флагов может быть несколько, и они могут идти в любом порядке.
Регулярное выражение с флагом выглядит так:
*/

//Пример
const regex1 = /смысл жизни/g; // здесь мы установили флаг g
const regex2 = /соль/gi; // тут установлены флаги g и i

/*
Флаг g - Если установить флаг g, мы будем искать все совпадения, а не только первое
*/
//Пример
const regex = /с/;
const regexGlobal = /с/g;
const word = 'искусство';

word.match(regex); // [ "с" ]
word.match(regexGlobal); // [ "с", "с", "с" ];

/*
Флаг i - Если поставить флаг i, поиск не будет различать строчных и прописных букв
*/
//Пример
const str = 'Вильгельм Конрад Рентген стал лауреатом Нобелевской премии в 1901 году.'

const regex = /рентген/;
const regexIgnore = /рентген/i;

str.match(regex); // null
str.match(regexIgnore); // [ "Рентген" ]

/*
Флаг m - Флаг m сработает, только если мы используем определённые спецсимволы, которых вы пока не знаете. 
Мы сначала разберём эти спецсимволы, а потом вернёмся к m
*/
//Пример


//==================================Спецсимволы и их обратные классы===============================================
/*
Представьте, что к нашей статье о телефонах появились новые комментарии. Теперь из всех комментаторов мы хотим отобрать 
пользователей тех моделей, у которых есть s на конце: Xs, 5s, 6s. Напишем регулярку:
*/
const regex = /iPhone .s/gi; // Поставим точку вместо номера модели
/*
Нам приходит на помощь точка. В шаблоне регулярного выражения она заменяет любой символ. 
Неважно, какая цифра стоит перед s, поэтому на её место в шаблоне мы ставим точку.
*/

//ЭКРАНИРОВАНИЕ
const str1 = 'yandex.ru/maps/';
const regex1 = /\.ru/; // экранировали точку
const regex2 = /\/maps/; // экранировали слеш перед словом maps

str1.match(regex1); // [ ".ru" ]
str1.match(regex2); // [ "/maps" ]

// Чтобы найти обратный слеш, его тоже нужно экранировать

const str2 = 'C:\\';
const regex3 = /\\/; // экранировали слеш

str2.match(regex3); // [ "\" ]