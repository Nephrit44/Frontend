//==================================Базовая конфигурация===============================================
const regex = /регулярно выражаюсь/; // Обязательно заключать в слеши (литералы регулярного выражения)
console.log(regex); // Результат: /регулярно выражаюсь/

//==================================Поисковая система===============================================
const userList = "Маша, Петя, Катя, Лёша, Лера, Иннокентий, Влад";
const innokentiy = /Иннокентий/g;
userList.match(innokentiy); // [ "Иннокентий" ]

//==================================Какой-то текст написанный рандомно===============================================
const comments = [
  "Я пользуюсь iPhone 6s — всё летает.",
  "У меня последний самсунг, всё хорошо.",
  "Зачем платить больше, если есть Xiaomi?",
  "Лучший телефон - Nokia 3310. У меня до сих пор работает.",
  "Только последний iPhone — там улучшили водонепроницаемость.",
];

const $_regex = /iPhone/;
const iPhoneComments = comments.filter((item) => $_regex.test(item));

/* метод test проверяет, есть ли искомая строка
в тексте и возвращает true или false.
Позже разберём этот метод подробно. */

console.log(iPhoneComments);

/* [
  "Я пользуюсь iPhone 6s — всё летает.",
  "Только последний iPhone — там улучшили водонепроницаемость."
] */

/*
На поиск влияют три сущности:
Спецсимволы — содержатся в самóм регулярном выражении и позволяют тоньше задать поиск. Например, искать в тексте сразу «Яндекс» и «Yandex».
Методы — определяют, что нужно делать, когда строка найдена: заменить её или сообщить, где произошло совпадение.
Флаги — кастомизируют работу метода, то есть увеличивают возможности. Например, выставив флаг, можно найти все совпадения с регуляркой или только одно.
Если кратко: спецсимволы определяют, что искать, методы — что делать, а флаги — как делать.
*/

//1.Методы строк:
const regex = /л/;
const word = "солнце";

word.match(regex); // [ "л" ] — метод нашёл символ в строке

/* match — строковый метод. Поэтому мы вызываем его
как метод строки, а регулярное выражение передаём как аргумент. */

//2.Методы регулярных выражений
const regex = /т/;
const word = "лестница";

regex.test(word); // true — метод подтвердил, что в строке есть совпадение

/* test — метод объекта RegExp. Поэтому мы вызываем его
как метод переменной regExp и передаём строку как аргумент. */

//==================================Флаги===============================================
/*
Флаг — символ, который стоит в регулярном выражении в самом конце (после слеша) и задаёт настройки поиска. 
Всего их шесть: g, i, m, u, y, s. В регулярном выражении флагов может быть несколько, и они могут идти в любом порядке.
Регулярное выражение с флагом выглядит так:
*/

//Пример
const regex1 = /смысл жизни/g; // здесь мы установили флаг g
const regex2 = /соль/gi; // тут установлены флаги g и i

/*
Флаг g - Если установить флаг g, мы будем искать все совпадения, а не только первое
*/
//Пример
const regex = /с/;
const regexGlobal = /с/g;
const word = 'искусство';

word.match(regex); // [ "с" ]
word.match(regexGlobal); // [ "с", "с", "с" ];

/*
Флаг i - Если поставить флаг i, поиск не будет различать строчных и прописных букв
*/
//Пример
const str = 'Вильгельм Конрад Рентген стал лауреатом Нобелевской премии в 1901 году.'

const regex = /рентген/;
const regexIgnore = /рентген/i;

str.match(regex); // null
str.match(regexIgnore); // [ "Рентген" ]

/*
Флаг m - Флаг m сработает, только если мы используем определённые спецсимволы, которых вы пока не знаете. 
Мы сначала разберём эти спецсимволы, а потом вернёмся к m
*/
//Пример


//==================================Спецсимволы и их обратные классы===============================================
/*
Представьте, что к нашей статье о телефонах появились новые комментарии. Теперь из всех комментаторов мы хотим отобрать 
пользователей тех моделей, у которых есть s на конце: Xs, 5s, 6s. Напишем регулярку:
*/
const regex = /iPhone .s/gi; // Поставим точку вместо номера модели
/*
Нам приходит на помощь точка. В шаблоне регулярного выражения она заменяет любой символ. 
Неважно, какая цифра стоит перед s, поэтому на её место в шаблоне мы ставим точку.
*/

//ЭКРАНИРОВАНИЕ
const str1 = 'yandex.ru/maps/';
const regex1 = /\.ru/; // экранировали точку
const regex2 = /\/maps/; // экранировали слеш перед словом maps

str1.match(regex1); // [ ".ru" ]
str1.match(regex2); // [ "/maps" ]

// Чтобы найти обратный слеш, его тоже нужно экранировать

const str2 = 'C:\\';
const regex3 = /\\/; // экранировали слеш

str2.match(regex3); // [ "\" ]

//Спецсимвол \w
//Этот спецсимвол говорит движку искать любую цифру, латинскую букву или нижнее подчёркивание:
const str = 'Простите, я отправил старую версию файла диплом_финал_2_копия_3.docx. Не смотрите не неё. Высылаю вам актуальную диплом_финал_2_копия_4.docx';

const regex = /диплом\wфинал\w\w\wкопия\w\w.docx/g;

str.match(regex);

// [ "диплом_финал_2_копия_3.docx", "диплом_финал_2_копия_4.docx" ]

/*
У спецсимвола \w есть обратный класс: \W. Если \w ищет цифры, латинские буквы и нижние подчёркивания, 
то \W ищет всё что угодно: знаки вопроса, пробелы, слеши, кириллические символы, — но только не цифры, буквы базовой латиницы и нижние подчёркивания.
Итак, обратный класс — это всё равно, что сказать «ищи НЕ такой-то спецсимвол».
*/

const str = `
  Даты основания некоторых IT-компаний:
  Yandex: 23.09.1997
  Apple: 01/04/1976
  IBM: 16-06-1911
`;

const regex = /\w\w\W\w\w\W\w\w\w\w/g;

/* цифры в дате мы обозначили строчной \w, а разделители —
заглавной \W. Разделитель это НЕ цифра, НЕ латинская буква
и НЕ нижнее подчёркивание. */

str.match(regex); // [ "23.09.1997", "01/04/1976", "16-06-1911" ]

//Спецсимвол \d совпадает с любой цифрой:
const str = 'Владивосток 2000';
const regex = /\d\d\d\d/g;

str.match(regex); // [ "2000" ]