//==================================Базовая конфигурация===============================================
const regex = /регулярно выражаюсь/; // Обязательно заключать в слеши (литералы регулярного выражения)
console.log(regex); // Результат: /регулярно выражаюсь/

//==================================Поисковая система===============================================
const userList = "Маша, Петя, Катя, Лёша, Лера, Иннокентий, Влад";
const innokentiy = /Иннокентий/g;
userList.match(innokentiy); // [ "Иннокентий" ]

//==================================Какой-то текст написанный рандомно===============================================
const comments = [
  "Я пользуюсь iPhone 6s — всё летает.",
  "У меня последний самсунг, всё хорошо.",
  "Зачем платить больше, если есть Xiaomi?",
  "Лучший телефон - Nokia 3310. У меня до сих пор работает.",
  "Только последний iPhone — там улучшили водонепроницаемость.",
];

const $_regex = /iPhone/;
const iPhoneComments = comments.filter((item) => $_regex.test(item));

/* метод test проверяет, есть ли искомая строка
в тексте и возвращает true или false.
Позже разберём этот метод подробно. */

console.log(iPhoneComments);

/* [
  "Я пользуюсь iPhone 6s — всё летает.",
  "Только последний iPhone — там улучшили водонепроницаемость."
] */

/*
На поиск влияют три сущности:
Спецсимволы — содержатся в самóм регулярном выражении и позволяют тоньше задать поиск. Например, искать в тексте сразу «Яндекс» и «Yandex».
Методы — определяют, что нужно делать, когда строка найдена: заменить её или сообщить, где произошло совпадение.
Флаги — кастомизируют работу метода, то есть увеличивают возможности. Например, выставив флаг, можно найти все совпадения с регуляркой или только одно.
Если кратко: спецсимволы определяют, что искать, методы — что делать, а флаги — как делать.
*/

//1.Методы строк:
const regex = /л/;
const word = "солнце";

word.match(regex); // [ "л" ] — метод нашёл символ в строке

/* match — строковый метод. Поэтому мы вызываем его
как метод строки, а регулярное выражение передаём как аргумент. */

//2.Методы регулярных выражений
const regex = /т/;
const word = "лестница";

regex.test(word); // true — метод подтвердил, что в строке есть совпадение

/* test — метод объекта RegExp. Поэтому мы вызываем его
как метод переменной regExp и передаём строку как аргумент. */

//==================================Флаги===============================================
/*
Флаг — символ, который стоит в регулярном выражении в самом конце (после слеша) и задаёт настройки поиска. 
Всего их шесть: g, i, m, u, y, s. В регулярном выражении флагов может быть несколько, и они могут идти в любом порядке.
Регулярное выражение с флагом выглядит так:
*/

//Пример
const regex1 = /смысл жизни/g; // здесь мы установили флаг g
const regex2 = /соль/gi; // тут установлены флаги g и i

/*
Флаг g - Если установить флаг g, мы будем искать все совпадения, а не только первое
*/
//Пример
const regex = /с/;
const regexGlobal = /с/g;
const word = 'искусство';

word.match(regex); // [ "с" ]
word.match(regexGlobal); // [ "с", "с", "с" ];

/*
Флаг i - Если поставить флаг i, поиск не будет различать строчных и прописных букв
*/
//Пример
const str = 'Вильгельм Конрад Рентген стал лауреатом Нобелевской премии в 1901 году.'

const regex = /рентген/;
const regexIgnore = /рентген/i;

str.match(regex); // null
str.match(regexIgnore); // [ "Рентген" ]

/*
Флаг m - Флаг m сработает, только если мы используем определённые спецсимволы, которых вы пока не знаете. 
Мы сначала разберём эти спецсимволы, а потом вернёмся к m
*/
//Пример


//==================================Спецсимволы и их обратные классы===============================================
/*
Представьте, что к нашей статье о телефонах появились новые комментарии. Теперь из всех комментаторов мы хотим отобрать 
пользователей тех моделей, у которых есть s на конце: Xs, 5s, 6s. Напишем регулярку:
*/
const regex = /iPhone .s/gi; // Поставим точку вместо номера модели
/*
Нам приходит на помощь точка. В шаблоне регулярного выражения она заменяет любой символ. 
Неважно, какая цифра стоит перед s, поэтому на её место в шаблоне мы ставим точку.
*/

//ЭКРАНИРОВАНИЕ
const str1 = 'yandex.ru/maps/';
const regex1 = /\.ru/; // экранировали точку
const regex2 = /\/maps/; // экранировали слеш перед словом maps

str1.match(regex1); // [ ".ru" ]
str1.match(regex2); // [ "/maps" ]

// Чтобы найти обратный слеш, его тоже нужно экранировать

const str2 = 'C:\\';
const regex3 = /\\/; // экранировали слеш

str2.match(regex3); // [ "\" ]

//Спецсимвол \w
//Этот спецсимвол говорит движку искать любую цифру, латинскую букву или нижнее подчёркивание:
const str = 'Простите, я отправил старую версию файла диплом_финал_2_копия_3.docx. Не смотрите не неё. Высылаю вам актуальную диплом_финал_2_копия_4.docx';

const regex = /диплом\wфинал\w\w\wкопия\w\w.docx/g;

str.match(regex);

// [ "диплом_финал_2_копия_3.docx", "диплом_финал_2_копия_4.docx" ]

/*
У спецсимвола \w есть обратный класс: \W. Если \w ищет цифры, латинские буквы и нижние подчёркивания, 
то \W ищет всё что угодно: знаки вопроса, пробелы, слеши, кириллические символы, — но только не цифры, буквы базовой латиницы и нижние подчёркивания.
Итак, обратный класс — это всё равно, что сказать «ищи НЕ такой-то спецсимвол».
*/

const str = `
  Даты основания некоторых IT-компаний:
  Yandex: 23.09.1997
  Apple: 01/04/1976
  IBM: 16-06-1911
`;

const regex = /\w\w\W\w\w\W\w\w\w\w/g;

/* цифры в дате мы обозначили строчной \w, а разделители —
заглавной \W. Разделитель это НЕ цифра, НЕ латинская буква
и НЕ нижнее подчёркивание. */

str.match(regex); // [ "23.09.1997", "01/04/1976", "16-06-1911" ]

//==================Спецсимвол \d  ищет совпадения с любой цифрой.:==================================
const str = 'Владивосток 2000';
const regex = /\d\d\d\d/g;

str.match(regex); // [ "2000" ]

//Спецсимвол \s
//Спецсимвол \s ищет «пустоты» в тексте: пробелы, в том числе неразрывные, переносы строк и табуляции.
const str = 'Сдают паспорта,\n' +
                    '              и я' +
                    '                сдаю';

const regex = /\s/g;

str.match(regex).length; // 32 — Маяковский любил пробелы 

//Его обратный класс \S ищет любые символы, только не пробелы, табуляции и переносы:

const str = 'Сдают паспорта,\n' +
                    '              и я' +
                    '                сдаю';

const regex = /\S/g;

str.match(regex).length; // 22

// букв с запятыми получилось на десяток меньше

/*
Спецсимвол \b
Возвращаемся к спецсимволам. \b означает границу слова. Движок считает границей слова:
начало строки;
конец строки;
любой символ, кроме цифр, латинских букв и нижнего подчёркивания.
Так мы можем находить символы в начале и в конце строки:

*/
const string = 'sadness';

string.match(/\bs/).index; // 0 — это первая буква s
// спецсимвол указал границу левее неё, т. е. начало

string.match(/s\b/).index; // 6 - а это последняя
// спецсимвол указал границу правее неё, т. е. конец

//======================НАБОР ДИАПАЗОНОВ========================================
//пример
// Ищем все символы «а» и «б»:
'барабан'.match(/[аб]/g); // [ "б", "а", "а", "б", "а" ]

const str = '14/03/2018';
const regex = /\d\d\W0[345]\W2018/g; // этот шаблон ищет все дни весны

str.match(regex); 

//=====================Диапазоны=================================================
const str = '20/04/2019';
const regex = /\d\d\W0[1-6]\W2019/g; // этот шаблон ищет все дни первого полугодия

str.match(regex); // [ "20/04/2019" ]

const regex = /[a-z0-9\-]/gi; // все латинские буквы, все цифры и дефис
const str = 'В Берлин я летал на boeing 737-800';

str.match(regex).join(''); // "boeing737-800" 

//===========================Кириллица======================================
const regex = /[\wа-я\sё]/gi;  //Обрати внимание на Ё

/* Ищем всю латиницу и всю кириллицу, все пробелы,
а от знаков препинания избавляемся. */

const str = 'Yandex 2020. Ещё не вечер!';

str.match(regex).join(''); // "Yandex 2020 Ещ не вечер"

//===========================Исключающие наборы и диапазоны=====================
/*
У наборов и диапазонов тоже есть противоположности — исключающие наборы и диапазоны. Они ищут все символы, кроме тех, что мы им перечислим.
Чтобы сделать набор или диапазон исключающим, перед ним нужно поставить «шляпку» ^ (карет):
*/

const str = 'Оценки за четверть: 2 3 3 5 2 4 2 3 5';
const regex = /[^1-3]/g;

str.match(regex).join(''); // "Оценки за четверть:    5  4   5"

// картина стала получше, но большие пустоты выдают обман

/[ac-]/; // это набор из трёх символов: a, c и -
/a-c/; // это уже диапазон из трёх символов: a, b и с


//======================================Квантификаторы===============================
//Предположим, мы хотим найти слово «свиной», но не помним, сколько в нём букв «н»:

const str = 'Сколько букв «н» в слове «свиной»?'; 
/*Для такого поиска нам нужно регулярное выражение. Оно ищет строку, которая начинается на «сви», 
затем идёт одна или две буквы «н», и конец слова: «ой».
От одного до бесконечности повторений — квантификатор +
Решить эту задачу поможет квантификатор +. Если поставить плюс после символа, движок ищет все слова, 
где этот символ встречается один раз или больше:
*/
const str = 'Правильно писать «свиной», с одной «н»';
const regex = /свин+ой/;

// такое регулярное выражение найдёт оба варианта: и с «н», и с «нн»

str.match(regex); // [ "свиной" ]

/*
От нуля до бесконечности повторений — квантификатор *
Другой квантификатор для поиска повторяющихся символов — это звёздочка (астериск): *. Работает почти как плюс, но есть одно отличие. 
Символ, после которого стоит плюс, обязательно должен быть в строке. То есть плюс как бы говорит движку: «Ищи вот этот символ и после
него ещё может быть сколько угодно таких же символов».
Звёздочку же устраивает и полное отсутствие того символа, который перед ней стоит. То есть если звёздочка стоит после символа, 
этого символа в найденной строке может вовсе не быть:
*/
const exc = 'экскаватор';
const esc = 'эскалатор';
const regex = /эк*ска[вл]атор/; // буква "к" может встречаться, а может и не встречаться

exc.match(regex); // [ "экскаватор" ]
esc.match(regex); // [ "эскалатор" ]

/*
Необязательный символ — квантификатор ?
Ещё один способ сделать символ необязательным: квантификатор ?. Если звёздочка приемлет от нуля до бесконечности символов, то знак вопроса строже — 
его устраивает лишь 0 и 1: либо есть один символ, либо его нет вообще.
*/
/* делает букву u необязательной и будет искать
оба варинта написания favourite и favorite. */

const regex = /favou?rite/g;
const    str = 'favourite for favorite';

str.match(regex); // ["favourite", "favorite"]

/*
Контроль повторов — квантификатор {}
Для поиска набора повторяющихся символов мы перечисляли их подряд в регулярном выражении:
*/
const regionCode = /\d\d\d/;
const    phoneNumber = 'Мой номер телефона: +7(999)123-12-21';

phoneNumber.match(regionCode); // [ "999" ]
/*
Квантификатор {} позволяет этого избежать. После символа можно поставить фигурные скобки и указать в них, сколько 
повторений этого символа мы хотим найти:
*/
const regionCode = /\d{3}/;
const    phoneNumber = 'Мой номер телефона: +7(999)123-12-21';

phoneNumber.match(regionCode); // [ "999" ]

/*
Верхнюю границу числа повторений можно не указывать: например, можно искать от 5 до бесконечности. В таких случаях просто не пишите в фигурных 
скобках второе число. Но запятую ставьте — она нужна.
*/
const someSymbol = /a{1,}/g;
const    str = 'alohaa';

console.log(str.match(someSymbol)); // ["a", "aa"]


+	от одного до бесконечности совпадений с символом подряд.
*	от нуля до бесконечности совпадений с символом подряд.
?	от нуля до одного совпадений с символом.
{}	точное количество совпадений или диапазон совпадений с символом подряд.


//================================================Начало и конец строки. Флаг m====================
/*
Начало и конец строки
Спецсимвол, обозначающий начало строки, — это шляпка ^, или карет. Она говорит шаблону, что нужно искать совпадение только с началом текста:
*/
const regex = /^\d+/g;
const newReg = /\d+/g;
const    str = '2001 год: Космическая одиссея, вышел в 1968 году';

str.match(regex); // [ "2001" ];
str.match(newReg); // [ "2001", "1968" ];


//Символ конца строки — знак доллара $. Аналогично указывает искать совпадение с концом текста:
const regex = /\d+$/;
const    str = 'https://praktikum.yandex.ru/trainer/frontend-developer/lesson/45';

str.match(regex); // ( ["45"] )

//=======================================Многострочные тексты================================
//Чтобы написать многострочный текст, перенос можно поставить комбинацией символов \n или пользоваться обычными переносами в шаблонных строках:
const str1 = `Председатель Совнаркома, Наркомпроса, Мининдела!
Эта местность мне знакома, как окраина Китая!`;
const str2 = 'Это утро, радость эта,\nЭта мощь и дня и света,'

const str = `Председатель Совнаркома, Наркомпроса, Мининдела!
Эта местность мне знакома, как окраина Китая!`;
const regex = /[А-Я]*!$/gi; // найдём последние слова каждой строки

str.match(regex); // ["Китая!"] — получилось только последнее слово всего текста 


//========================================Методы для регулярных выражений======================================
//Метод String.split
'Пришёл. Увидел. Победил.'.split(' '); // ["Пришёл.", "Увидел.", "Победил."]
'Пришёл. Увидел. Победил.'.split('. '); // ["Пришёл", "Увидел", "Победил."]

const regex = /\n/im;

`Мой дядя самых честных правил,
Когда не в шутку занемог,
Он уважать себя заставил
И лучше выдумать не мог.`.split(regex);

/* [
    "Мой дядя самых честных правил,",
    "Когда не в шутку занемог,",
    "Он уважать себя заставил",
    "И лучше выдумать не мог."
] */ 

/*
Обратите внимание: метод String.split ожидает, что какой-то элемент должен быть и до, и после разделителя. Поэтому если ваша строка начинается с 
разделителя или заканчивается разделителем, в полученном массиве первым или последним элементом будет пустая строка.
*/

//Метод RegExp.test
//Мы уже упоминали о методе RegExp.test. Он вызывается на регулярном выражении, а строку принимает на вход. Результат работы метода — 
//булевое значение. Если совпадение найти удалось, RegExp.test вернёт true:

const regex = /\w+@\w+\.\w+/; // шаблон для поиска email
const str = 'Stas Basov: stasbasov@yandex.ru';

regex.test(str); // true 

/*Если установить флаг g, метод RegExp.test будет вести себя несколько иначе. 
Он вернёт первое совпадение, а затем — запишет в свойство lastIndex регулярного выражения номер символа в тексте, 
на котором это совпадение произошло.
Если запустить метод RegExp.test снова, он будет искать не с начала строки, а с того символа, на котором остановился 
в прошлый раз. То есть с записанного в свойство lastIndex:*/

const regex = /\w+@\w+\.\w+/g;
const str = 'Stas Basov: stas-basov@yandex.ru, Telegramm: basov-stas';

regex.test(str); // true
regex.lastIndex; // 32 - номер символа, где было найдено совпадение

// Вызовем метод RegExp.test ещё раз:
regex.test(str); // false - поиск начался с 32 символа, поэтому совпадения найдены не были
regex.lastIndex; // 0 

/* предыдущий поиск не дал результатов,
поэтому свойство lastIndex было сброшено до нуля */ 